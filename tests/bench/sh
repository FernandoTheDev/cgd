#!/bin/bash

# Advanced Multi-Language Benchmark - N√∫meros Primos
# Compara√ß√£o justa entre linguagens interpretadas e compiladas
# Usando comando 'time' para medi√ß√£o precisa

echo "=============================================================="
echo "    BENCHMARK AVAN√áADO MULTI-LINGUAGEM - N√öMEROS PRIMOS"
echo "      Compara√ß√£o justa: Interpretadas vs Compiladas"
echo "=============================================================="
echo

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Configura√ß√µes do benchmark
LIMITE_DEFAULT=1000000
RUNS=5
TIMEOUT=120
WARMUP_RUNS=2

# Arrays para rastrear linguagens dispon√≠veis
declare -a AVAILABLE_LANGS=()
declare -a COMPILED_LANGS=()
declare -a INTERPRETED_LANGS=()

# Fun√ß√£o para criar algoritmo otimizado em Python
create_python_script() {
    cat << 'EOF' > benchmark_prime.py
import math

def eh_primo(n):
    if n < 2: return False
    if n == 2: return True
    if n % 2 == 0: return False
    
    # Otimiza√ß√£o: usar int ao inv√©s de float
    limite = int(math.sqrt(n)) + 1
    for i in range(3, limite, 2):
        if n % i == 0: return False
    return True

def contar_primos(limite):
    contador = 0
    for numero in range(2, limite + 1):
        if eh_primo(numero):
            contador += 1
    return contador

def main():
    limite = LIMITE_DEFAULT
    
    # Warm-up para JIT
    contar_primos(1000)
    
    resultado = contar_primos(limite)
    print(f"RESULT:{resultado}")

if __name__ == "__main__":
    main()
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.py
}

# Fun√ß√£o para criar algoritmo otimizado em JavaScript
create_javascript_script() {
    cat << 'EOF' > benchmark_prime.js
function ehPrimo(n) {
    if (n < 2) return false;
    if (n === 2) return true;
    if (n % 2 === 0) return false;
    
    const limite = Math.floor(Math.sqrt(n));
    for (let i = 3; i <= limite; i += 2) {
        if (n % i === 0) return false;
    }
    return true;
}

function contarPrimos(limite) {
    let contador = 0;
    for (let numero = 2; numero <= limite; numero++) {
        if (ehPrimo(numero)) contador++;
    }
    return contador;
}

function main() {
    const limite = LIMITE_DEFAULT;
    
    // Warm-up para V8
    contarPrimos(1000);
    
    const resultado = contarPrimos(limite);
    console.log(`RESULT:${resultado}`);
}

main();
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.js
}

# Fun√ß√£o para criar algoritmo em C
create_c_script() {
    cat << 'EOF' > benchmark_prime.c
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

bool eh_primo(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    int limite = (int)sqrt(n);
    for (int i = 3; i <= limite; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

int contar_primos(int limite) {
    int contador = 0;
    for (int numero = 2; numero <= limite; numero++) {
        if (eh_primo(numero)) contador++;
    }
    return contador;
}

int main() {
    int limite = LIMITE_DEFAULT;
    
    int resultado = contar_primos(limite);
    printf("RESULT:%d\n", resultado);
    
    return 0;
}
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.c
}

# Fun√ß√£o para criar algoritmo em C++
create_cpp_script() {
    cat << 'EOF' > benchmark_prime.cpp
#include <iostream>
#include <cmath>

bool eh_primo(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    int limite = static_cast<int>(std::sqrt(n));
    for (int i = 3; i <= limite; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

int contar_primos(int limite) {
    int contador = 0;
    for (int numero = 2; numero <= limite; numero++) {
        if (eh_primo(numero)) contador++;
    }
    return contador;
}

int main() {
    int limite = LIMITE_DEFAULT;
    
    int resultado = contar_primos(limite);
    std::cout << "RESULT:" << resultado << std::endl;
    
    return 0;
}
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.cpp
}

# Fun√ß√£o para criar algoritmo em Go
create_go_script() {
    cat << 'EOF' > benchmark_prime.go
package main

import (
    "fmt"
    "math"
)

func ehPrimo(n int) bool {
    if n < 2 { return false }
    if n == 2 { return true }
    if n % 2 == 0 { return false }
    
    limite := int(math.Sqrt(float64(n)))
    for i := 3; i <= limite; i += 2 {
        if n % i == 0 { return false }
    }
    return true
}

func contarPrimos(limite int) int {
    contador := 0
    for numero := 2; numero <= limite; numero++ {
        if ehPrimo(numero) {
            contador++
        }
    }
    return contador
}

func main() {
    limite := LIMITE_DEFAULT
    
    resultado := contarPrimos(limite)
    fmt.Printf("RESULT:%d\n", resultado)
}
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.go
}

# Fun√ß√£o para criar algoritmo em Rust
create_rust_script() {
    cat << 'EOF' > benchmark_prime.rs
fn eh_primo(n: u32) -> bool {
    if n < 2 { return false; }
    if n == 2 { return true; }
    if n % 2 == 0 { return false; }
    
    let limite = (n as f64).sqrt() as u32;
    for i in (3..=limite).step_by(2) {
        if n % i == 0 { return false; }
    }
    true
}

fn contar_primos(limite: u32) -> u32 {
    let mut contador = 0;
    for numero in 2..=limite {
        if eh_primo(numero) {
            contador += 1;
        }
    }
    contador
}

fn main() {
    let limite = LIMITE_DEFAULT;
    
    let resultado = contar_primos(limite);
    println!("RESULT:{}", resultado);
}
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.rs
}

# Fun√ß√£o para criar algoritmo em Java
create_java_script() {
    cat << 'EOF' > BenchmarkPrime.java
public class BenchmarkPrime {
    
    public static boolean ehPrimo(int n) {
        if (n < 2) return false;
        if (n == 2) return true;
        if (n % 2 == 0) return false;
        
        int limite = (int) Math.sqrt(n);
        for (int i = 3; i <= limite; i += 2) {
            if (n % i == 0) return false;
        }
        return true;
    }
    
    public static int contarPrimos(int limite) {
        int contador = 0;
        for (int numero = 2; numero <= limite; numero++) {
            if (ehPrimo(numero)) contador++;
        }
        return contador;
    }
    
    public static void main(String[] args) {
        int limite = LIMITE_DEFAULT;
        
        // Warm-up para JVM
        contarPrimos(1000);
        
        int resultado = contarPrimos(limite);
        System.out.printf("RESULT:%d%n", resultado);
    }
}
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" BenchmarkPrime.java
}

# Fun√ß√£o para criar algoritmo em Del√©gua
create_delegua_script() {
    cat << 'EOF' > benchmark_prime.delegua
fun√ß√£o ehPrimo(n) {
    se (n < 2) retorna falso
    se (n == 2) retorna verdadeiro
    se (n % 2 == 0) retorna falso
    
    var limite = inteiro(n ** 0.5)
    para var i = 3; i <= limite; i = i + 2 {
        se (n % i == 0) retorna falso
    }
    retorna verdadeiro
}

fun√ß√£o contarPrimos(limite) {
    var contador = 0
    para var numero = 2; numero <= limite; numero = numero + 1 {
        se (ehPrimo(numero)) {
            contador = contador + 1
        }
    }
    retorna contador
}

var limite = LIMITE_DEFAULT
var resultado = contarPrimos(limite)
escrever("RESULT:", resultado)
EOF
    sed -i "s/LIMITE_DEFAULT/$LIMITE_DEFAULT/g" benchmark_prime.delegua
}

# Fun√ß√£o para otimizar o sistema para benchmarking
optimize_system() {
    echo -e "${YELLOW}üîß Otimizando sistema para benchmark...${NC}"
    
    # Verificar se rodando como root para otimiza√ß√µes do sistema
    if [ "$EUID" -eq 0 ]; then
        echo -e "${GREEN}   ‚úì Executando como root - aplicando otimiza√ß√µes do sistema${NC}"
        
        # Desabilitar CPU frequency scaling temporariamente
        if [ -d /sys/devices/system/cpu/cpu0/cpufreq ]; then
            echo "performance" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null
            echo -e "${GREEN}   ‚úì CPU governor definido para 'performance'${NC}"
        fi
        
        # Sync filesystem
        sync
        echo -e "${GREEN}   ‚úì Filesystem sincronizado${NC}"
        
    else
        echo -e "${CYAN}   ‚Ñπ Para m√°xima precis√£o, execute como root para otimiza√ß√µes do sistema${NC}"
    fi
    
    # For√ßa garbage collection se dispon√≠vel
    which python3 >/dev/null 2>&1 && python3 -c "import gc; gc.collect()" 2>/dev/null
    
    echo -e "${GREEN}   ‚úì Sistema otimizado${NC}"
}

# Fun√ß√£o para verificar e compilar linguagens
setup_languages() {
    echo -e "${YELLOW}üîß Configurando linguagens...${NC}"
    
    # Python
    if command -v python3 >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Python 3 detectado${NC}"
        AVAILABLE_LANGS+=("Python")
        INTERPRETED_LANGS+=("Python")
        create_python_script
    fi
    
    # JavaScript (Node.js)
    if command -v node >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Node.js detectado${NC}"
        AVAILABLE_LANGS+=("JavaScript")
        INTERPRETED_LANGS+=("JavaScript")
        create_javascript_script
    fi
    
    # Java
    if command -v javac >/dev/null 2>&1 && command -v java >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Java detectado - compilando...${NC}"
        create_java_script
        if javac BenchmarkPrime.java 2>/dev/null; then
            AVAILABLE_LANGS+=("Java")
            COMPILED_LANGS+=("Java")
            echo -e "${GREEN}   ‚úì Java compilado com sucesso${NC}"
        else
            echo -e "${RED}   ‚úó Erro na compila√ß√£o Java${NC}"
        fi
    fi
    
    # C
    if command -v gcc >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ GCC detectado - compilando C...${NC}"
        create_c_script
        if gcc -O3 -march=native -flto -lm benchmark_prime.c -o benchmark_prime_c 2>/dev/null; then
            AVAILABLE_LANGS+=("C")
            COMPILED_LANGS+=("C")
            echo -e "${GREEN}   ‚úì C compilado com sucesso${NC}"
        else
            echo -e "${RED}   ‚úó Erro na compila√ß√£o C${NC}"
        fi
    fi
    
    # C++
    if command -v g++ >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ G++ detectado - compilando C++...${NC}"
        create_cpp_script
        if g++ -O3 -march=native -flto -std=c++17 benchmark_prime.cpp -o benchmark_prime_cpp 2>/dev/null; then
            AVAILABLE_LANGS+=("C++")
            COMPILED_LANGS+=("C++")
            echo -e "${GREEN}   ‚úì C++ compilado com sucesso${NC}"
        else
            echo -e "${RED}   ‚úó Erro na compila√ß√£o C++${NC}"
        fi
    fi
    
    # Go
    if command -v go >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Go detectado - compilando...${NC}"
        create_go_script
        if go build -ldflags="-s -w" -o benchmark_prime_go benchmark_prime.go 2>/dev/null; then
            AVAILABLE_LANGS+=("Go")
            COMPILED_LANGS+=("Go")
            echo -e "${GREEN}   ‚úì Go compilado com sucesso${NC}"
        else
            echo -e "${RED}   ‚úó Erro na compila√ß√£o Go${NC}"
        fi
    fi
    
    # Rust
    if command -v rustc >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Rust detectado - compilando...${NC}"
        create_rust_script
        if rustc -C opt-level=3 -C target-cpu=native -C lto benchmark_prime.rs -o benchmark_prime_rust 2>/dev/null; then
            AVAILABLE_LANGS+=("Rust")
            COMPILED_LANGS+=("Rust")
            echo -e "${GREEN}   ‚úì Rust compilado com sucesso${NC}"
        else
            echo -e "${RED}   ‚úó Erro na compila√ß√£o Rust${NC}"
        fi
    fi
    
    # Del√©gua
    if [ -x "./n_primo" ]; then
        echo -e "${GREEN}‚úÖ Del√©gua detectado"
        AVAILABLE_LANGS+=("Del√©gua")
        COMPILED_LANGS+=("Del√©gua")
    fi
    
    echo -e "${BLUE}üìä Total de linguagens dispon√≠veis: ${#AVAILABLE_LANGS[@]}${NC}"
    echo -e "${CYAN}   Compiladas: ${COMPILED_LANGS[*]}${NC}"
    echo -e "${CYAN}   Interpretadas: ${INTERPRETED_LANGS[*]}${NC}"
    echo
}

# Fun√ß√£o para fazer warm-up das linguagens interpretadas
warmup_language() {
    local lang=$1
    local command=$2
    
    echo -e "${CYAN}   üî• Fazendo warm-up para $lang...${NC}"
    
    for i in $(seq 1 $WARMUP_RUNS); do
        timeout 30s bash -c "$command" >/dev/null 2>&1
    done
    
    # Pausa breve para estabilizar
    sleep 1
}

# Fun√ß√£o para medir tempo com m√∫ltiplas estrat√©gias
# Fun√ß√£o para medir tempo com m√∫ltiplas estrat√©gias - VERS√ÉO CORRIGIDA
measure_execution_time() {
    local command=$1
    local lang=$2
    
    # Usar diret√≥rio tempor√°rio √∫nico
    local temp_dir=$(mktemp -d)
    local time_file="$temp_dir/time_output"
    local result_file="$temp_dir/result_output"
    local stderr_file="$temp_dir/stderr_output"
    
    # Executar comando com redirecionamento correto
    local exit_code=1
    local attempts=0
    local max_attempts=3
    
    while [ $attempts -lt $max_attempts ] && [ $exit_code -ne 0 ]; do
        attempts=$((attempts + 1))
        
        # Sincronizar antes da execu√ß√£o
        sync
        
        # CORRE√á√ÉO: Separar stdout, stderr e dados do time corretamente
        timeout ${TIMEOUT}s /usr/bin/time -f '%e %U %S' -o "$time_file" \
            bash -c "$command" > "$result_file" 2> "$stderr_file"
        exit_code=$?
        
        # Se falhou, aguardar um pouco antes de tentar novamente
        if [ $exit_code -ne 0 ] && [ $attempts -lt $max_attempts ]; then
            sleep 2
        fi
    done
    
    # Processar resultados
    local exec_time=""
    local output=""
    local valid=false
    
    if [ $exit_code -eq 0 ]; then
        # Ler tempo de execu√ß√£o
        if [ -s "$time_file" ]; then
            exec_time=$(cat "$time_file" 2>/dev/null | tr -d ' \n\r')
        fi
        
        # Ler sa√≠da do programa (stdout)
        if [ -s "$result_file" ]; then
            output=$(cat "$result_file" 2>/dev/null | tr -d '\r')
        fi
        
        # DEBUG: Mostrar conte√∫do dos arquivos
        echo -e "${YELLOW}DEBUG: Arquivo time: '$(cat "$time_file" 2>/dev/null)'${NC}" >&2
        echo -e "${YELLOW}DEBUG: Arquivo result: '$(cat "$result_file" 2>/dev/null)'${NC}" >&2
        echo -e "${YELLOW}DEBUG: Arquivo stderr: '$(cat "$stderr_file" 2>/dev/null)'${NC}" >&2
        
        # Validar tempo e resultado
        if [[ $exec_time =~ ^[0-9]+\.?[0-9]*$ ]] && [[ $output =~ RESULT:([0-9]+) ]]; then
            valid=true
        fi
    fi
    
    # Limpar arquivos tempor√°rios
    rm -rf "$temp_dir"
    
    if [ "$valid" = true ]; then
        echo "$exec_time|$output"
        return 0
    else
        echo "FAILED|$output"
        return 1
    fi
}

# Fun√ß√£o para executar benchmark de uma linguagem usando medi√ß√£o precisa
run_single_benchmark() {
    local lang=$1
    local command=$2
    
    echo -e "${BLUE}üîÑ Testando $lang...${NC}"
    
    # Warm-up para linguagens interpretadas
    for interpreted in "${INTERPRETED_LANGS[@]}"; do
        if [ "$interpreted" = "$lang" ]; then
            warmup_language "$lang" "$command"
            break
        fi
    done
    
    local times=()
    local results=()
    local successful_runs=0
    
    for i in $(seq 1 $RUNS); do
        echo -en "${CYAN}   Execu√ß√£o $i/$RUNS... ${NC}"
        
        local measurement=$(measure_execution_time "$command" "$lang")
        local measure_exit=$?
        
        if [ $measure_exit -eq 0 ]; then
            local exec_time=$(echo "$measurement" | cut -d'|' -f1)
            local output=$(echo "$measurement" | cut -d'|' -f2)
            
            # VALIDA√á√ÉO CR√çTICA: verificar se exec_time √© um n√∫mero v√°lido
            if [[ $exec_time =~ ^[0-9]+\.?[0-9]*$ ]] && [[ $output =~ RESULT:([0-9]+) ]]; then
                local result="${BASH_REMATCH[1]}"
                echo -e "${GREEN}‚úì ${exec_time}s (${result} primos)${NC}"
                times+=($exec_time)
                results+=($result)
                successful_runs=$((successful_runs + 1))
            else
                echo -e "${RED}‚úó Tempo inv√°lido: '$exec_time'${NC}"
            fi
        else
            echo -e "${RED}‚úó Falhou na medi√ß√£o${NC}"
        fi
    done
    
    # PROTE√á√ÉO contra divis√£o por zero e valores inv√°lidos:
    if [ $successful_runs -eq 0 ]; then
        echo "$lang,FALHA,FALHA,FALHA,FALHA,0,$lang_type" >> benchmark_results.tmp
        return 1
    fi
    
    # Calcular apenas se temos valores v√°lidos
    local total_time=0
    for time in "${times[@]}"; do
        if [[ $time =~ ^[0-9]+\.?[0-9]*$ ]]; then
            total_time=$(echo "$total_time + $time" | bc -l)
        fi
    done
    
    # Evitar divis√£o por zero
    if [ $successful_runs -gt 0 ]; then
        local avg_time=$(echo "scale=6; $total_time / $successful_runs" | bc -l)
    else
        local avg_time="FALHA"
    fi
    
    # Calcular estat√≠sticas com maior precis√£o
    local total_time=0
    for time in "${times[@]}"; do
        total_time=$(echo "$total_time + $time" | bc -l)
    done
    
    local avg_time=$(echo "scale=6; $total_time / $successful_runs" | bc -l)
    
    # Encontrar min e max
    local min_time=${times[0]}
    local max_time=${times[0]}
    for time in "${times[@]}"; do
        if (( $(echo "$time < $min_time" | bc -l) )); then
            min_time=$time
        fi
        if (( $(echo "$time > $max_time" | bc -l) )); then
            max_time=$time
        fi
    done
    
    # Calcular desvio padr√£o
    local variance=0
    for time in "${times[@]}"; do
        local diff=$(echo "$time - $avg_time" | bc -l)
        local sq_diff=$(echo "$diff * $diff" | bc -l)
        variance=$(echo "$variance + $sq_diff" | bc -l)
    done
    variance=$(echo "scale=6; $variance / $successful_runs" | bc -l)
    local std_dev=$(echo "scale=6; sqrt($variance)" | bc -l)
    
    echo -e "${GREEN}   üìä M√©dia: ${avg_time}s ¬± ${std_dev}s | Min: ${min_time}s | Max: ${max_time}s${NC}"
    
    # Verificar consist√™ncia dos resultados
    local first_result=${results[0]}
    local consistent=true
    for result in "${results[@]}"; do
        if [ "$result" != "$first_result" ]; then
            consistent=false
            break
        fi
    done
    
    if [ "$consistent" = false ]; then
        echo -e "${RED}   ‚ö†Ô∏è  Resultados inconsistentes detectados!${NC}"
    fi
    
    # Determinar tipo de linguagem
    local lang_type="Interpretada"
    for compiled in "${COMPILED_LANGS[@]}"; do
        if [ "$compiled" = "$lang" ]; then
            lang_type="Compilada"
            break
        fi
    done
    
    echo "$lang,$avg_time,$min_time,$max_time,$std_dev,$successful_runs,$lang_type" >> benchmark_results.tmp
    echo
}

# Fun√ß√£o para executar todos os benchmarks
run_all_benchmarks() {
    echo -e "${YELLOW}üöÄ Iniciando benchmarks com limite de ${LIMITE_DEFAULT} n√∫meros...${NC}"
    echo -e "${YELLOW}‚è±Ô∏è  Usando medi√ß√£o de tempo de alta precis√£o${NC}"
    echo
    
    rm -f benchmark_results.tmp
    
    # Executar benchmarks para cada linguagem dispon√≠vel
    for lang in "${AVAILABLE_LANGS[@]}"; do
        case $lang in
            "Python")
                run_single_benchmark "Python" "python3 -O benchmark_prime.py"
                ;;
            "JavaScript")
                run_single_benchmark "JavaScript" "node --optimize_for_size benchmark_prime.js"
                ;;
            "Java")
                run_single_benchmark "Java" "java -XX:+UseG1GC -XX:+OptimizeStringConcat BenchmarkPrime"
                ;;
            "C")
                run_single_benchmark "C" "./benchmark_prime_c"
                ;;
            "C++")
                run_single_benchmark "C++" "./benchmark_prime_cpp"
                ;;
            "Go")
                run_single_benchmark "Go" "./benchmark_prime_go"
                ;;
            "Rust")
                run_single_benchmark "Rust" "./benchmark_prime_rust"
                ;;
            "Del√©gua")
                run_single_benchmark "Del√©gua" "./n_primo"
                ;;
        esac
    done
}

# Fun√ß√£o para mostrar resultados detalhados
show_detailed_results() {
    if [ ! -f benchmark_results.tmp ]; then
        echo -e "${RED}‚ùå Nenhum resultado dispon√≠vel${NC}"
        return 1
    fi
    
    echo "=============================================================="
    echo -e "${BOLD}${GREEN}                    RESULTADOS DETALHADOS${NC}"
    echo "=============================================================="
    echo
    
    # Separar por tipo
    echo -e "${BLUE}üìä LINGUAGENS COMPILADAS:${NC}"
    echo "Linguagem       | Tempo M√©dio | Desvio   | Tempo M√≠n | Tempo M√°x | Runs"
    echo "----------------|-----------‚Äì-|----------|-----------|-----------|------"
    
    grep "Compilada" benchmark_results.tmp | sort -t',' -k2 -n | while IFS=',' read -r lang avg_time min_time max_time std_dev runs type; do
        if [ "$runs" != "0" ] && [ "$avg_time" != "FALHA" ]; then
            printf "%-15s | %9ss | %6ss | %7ss | %7ss | %2s/%-2s\n" "$lang" "$avg_time" "$std_dev" "$min_time" "$max_time" "$runs" "$RUNS"
        fi
    done
    
    echo
    echo -e "${PURPLE}üìä LINGUAGENS INTERPRETADAS:${NC}"
    echo "Linguagem       | Tempo M√©dio | Desvio   | Tempo M√≠n | Tempo M√°x | Runs"
    echo "----------------|-----------‚Äì-|----------|-----------|-----------|------"
    
    grep "Interpretada" benchmark_results.tmp | sort -t',' -k2 -n | while IFS=',' read -r lang avg_time min_time max_time std_dev runs type; do
        if [ "$runs" != "0" ] && [ "$avg_time" != "FALHA" ]; then
            printf "%-15s | %9ss | %6ss | %7ss | %7ss | %2s/%-2s\n" "$lang" "$avg_time" "$std_dev" "$min_time" "$max_time" "$runs" "$RUNS"
        fi
    done
    
    echo
    echo -e "${BOLD}üèÜ RANKING GERAL (por tempo m√©dio):${NC}"
    echo "Pos | Linguagem       | Tempo M√©dio | Desvio   | Tipo         | Speedup"
    echo "----|-----------------|-------------|----------|--------------|--------"
    
    local pos=1
    local fastest_time=""
    
    sort -t',' -k2 -n benchmark_results.tmp | while IFS=',' read -r lang avg_time min_time max_time std_dev runs type; do
        if [ "$runs" != "0" ] && [ "$avg_time" != "FALHA" ]; then
            if [ "$fastest_time" = "0" ] || [ "$fastest_time" = "0.00" ]; then
                speedup="N/A"
            else
                speedup=$(echo "scale=2; $avg_time / $fastest_time" | bc -l)
                speedup="${speedup}x"
            fi
            
            printf "%2d  | %-15s | %9ss | %6ss | %-12s | %s\n" "$pos" "$lang" "$avg_time" "$std_dev" "$type" "$speedup"
            pos=$((pos + 1))
        fi
    done
    
    echo
    
    # An√°lise adicional
    local fastest=$(sort -t',' -k2 -n benchmark_results.tmp | head -n1)
    local fastest_name=$(echo "$fastest" | cut -d',' -f1)
    local fastest_time=$(echo "$fastest" | cut -d',' -f2)
    local fastest_type=$(echo "$fastest" | cut -d',' -f7)
    local fastest_std=$(echo "$fastest" | cut -d',' -f5)
    
    echo -e "${GREEN}ü•á VENCEDOR: ${BOLD}$fastest_name${NC}${GREEN} (${fastest_type})${NC}"
    echo -e "${GREEN}   Tempo: ${fastest_time}s ¬± ${fastest_std}s${NC}"
    echo
    
    # Estat√≠sticas de precis√£o
    echo -e "${CYAN}üìà ESTAT√çSTICAS DE PRECIS√ÉO:${NC}"
    while IFS=',' read -r lang avg_time min_time max_time std_dev runs type; do
        if [ "$runs" != "0" ] && [ "$avg_time" != "FALHA" ]; then
            local cv=$(echo "scale=2; $std_dev / $avg_time * 100" | bc -l)
            echo -e "${CYAN}   $lang: CV = ${cv}%${NC}"
        fi
    done < benchmark_results.tmp
    echo
}

# Fun√ß√£o para limpeza
cleanup() {
    echo -e "${BLUE}üßπ Limpando arquivos tempor√°rios...${NC}"
    rm -f benchmark_prime.* BenchmarkPrime.* benchmark_prime_* *.class benchmark_results.tmp
    
    # Restaurar configura√ß√µes do sistema se executando como root
    if [ "$EUID" -eq 0 ] && [ -d /sys/devices/system/cpu/cpu0/cpufreq ]; then
        echo "ondemand" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null || \
        echo "schedutil" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null
        echo -e "${GREEN}   ‚úì CPU governor restaurado${NC}"
    fi
}

# Fun√ß√£o para detectar interfer√™ncia do sistema
detect_system_load() {
    local load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')
    local cpu_count=$(nproc)
    local load_per_cpu=$(echo "scale=2; $load_avg / $cpu_count" | bc -l)
    
    if (( $(echo "$load_per_cpu > 0.5" | bc -l) )); then
        echo -e "${YELLOW}‚ö†Ô∏è  Sistema com carga moderada (load avg: $load_avg)${NC}"
        echo -e "${YELLOW}   Para resultados mais precisos, feche outros programas${NC}"
        return 1
    fi
    
    return 0
}

# Fun√ß√£o para validar ambiente de benchmark
validate_environment() {
    echo -e "${YELLOW}üîç Validando ambiente de benchmark...${NC}"
    
    # Verificar depend√™ncias cr√≠ticas
    local missing_deps=()
    
    if ! command -v bc >/dev/null 2>&1; then
        missing_deps+=("bc")
    fi
    
    if ! [ -x "/usr/bin/time" ]; then
        missing_deps+=("time")
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo -e "${RED}‚ùå Depend√™ncias faltando: ${missing_deps[*]}${NC}"
        echo -e "${RED}   Instale com: sudo apt install ${missing_deps[*]}${NC}"
        return 1
    fi
    
    # Verificar carga do sistema
    detect_system_load
    
    # Verificar espa√ßo em disco
    local available_space=$(df /tmp | awk 'NR==2 {print $4}')
    if [ "$available_space" -lt 100000 ]; then  # Menos que 100MB
        echo -e "${YELLOW}‚ö†Ô∏è  Pouco espa√ßo em /tmp (${available_space}KB dispon√≠vel)${NC}"
    fi
    
    # Verificar se h√° swapping ativo
    if [ -f /proc/swaps ]; then
        local swap_usage=$(awk 'NR>1 {sum+=$4} END {print sum+0}' /proc/swaps)
        if [ "$swap_usage" -gt 0 ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Swap em uso (${swap_usage}KB) - pode afetar a precis√£o${NC}"
        fi
    fi
    
    echo -e "${GREEN}‚úì Ambiente validado${NC}"
    return 0
}

# Fun√ß√£o principal
main() {
   echo -e "${BOLD}Configura√ß√µes do Benchmark:${NC}"
   echo "‚Ä¢ Limite de n√∫meros: $LIMITE_DEFAULT"
   echo "‚Ä¢ Execu√ß√µes por linguagem: $RUNS"
   echo "‚Ä¢ Execu√ß√µes de warm-up: $WARMUP_RUNS"
   echo "‚Ä¢ Timeout por execu√ß√£o: ${TIMEOUT}s"
   echo "‚Ä¢ Otimiza√ß√µes: Habilitadas (m√°ximas por linguagem)"
   echo "‚Ä¢ Medi√ß√£o: /usr/bin/time com alta precis√£o"
   echo "‚Ä¢ Estat√≠sticas: M√©dia, desvio padr√£o, min/max"
   echo
   
   # Validar ambiente
   if ! validate_environment; then
       exit 1
   fi
   
   # Otimizar sistema
   optimize_system
   
   setup_languages
   
   if [ ${#AVAILABLE_LANGS[@]} -eq 0 ]; then
       echo -e "${RED}‚ùå Nenhuma linguagem dispon√≠vel para teste${NC}"
       exit 1
   fi
   
   # Configurar trap para limpeza em caso de interrup√ß√£o
   trap cleanup EXIT INT TERM
   
   run_all_benchmarks
   show_detailed_results
   
   echo -e "${GREEN}‚úÖ Benchmark conclu√≠do com sucesso!${NC}"
   echo
   echo -e "${YELLOW}üí° Dicas para m√°xima precis√£o:${NC}"
   echo "‚Ä¢ Execute como root para otimiza√ß√µes do sistema"
   echo "‚Ä¢ Execute m√∫ltiplas vezes para verificar consist√™ncia"
   echo "‚Ä¢ Feche outros programas para reduzir interfer√™ncia"
   echo "‚Ä¢ Use 'nice -n -20 sudo ./benchmark.sh' para prioridade m√°xima"
   echo "‚Ä¢ Monitore o coeficiente de varia√ß√£o (CV) para avaliar precis√£o"
   echo "‚Ä¢ CV < 5% indica medi√ß√µes muito precisas"
   echo "‚Ä¢ CV > 15% indica poss√≠vel interfer√™ncia do sistema"
}

main
